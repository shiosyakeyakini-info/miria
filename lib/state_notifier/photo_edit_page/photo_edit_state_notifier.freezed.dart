// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'photo_edit_state_notifier.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PhotoEdit {
  bool get clipMode => throw _privateConstructorUsedError;
  bool get colorFilterMode => throw _privateConstructorUsedError;
  List<ColorFilterPreview> get colorFilterPreviewImages =>
      throw _privateConstructorUsedError;
  List<String> get adaptivePresets => throw _privateConstructorUsedError;
  bool get isInitialized => throw _privateConstructorUsedError;
  Uint8List? get initialImage => throw _privateConstructorUsedError;
  Uint8List? get editedImage => throw _privateConstructorUsedError;
  Offset get cropOffset => throw _privateConstructorUsedError;
  Size get cropSize => throw _privateConstructorUsedError;
  Size get defaultSize => throw _privateConstructorUsedError;
  Size get actualSize => throw _privateConstructorUsedError;
  int get angle => throw _privateConstructorUsedError;
  List<EditedEmojiData> get emojis => throw _privateConstructorUsedError;
  int? get selectedEmojiIndex => throw _privateConstructorUsedError;

  /// Create a copy of PhotoEdit
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PhotoEditCopyWith<PhotoEdit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhotoEditCopyWith<$Res> {
  factory $PhotoEditCopyWith(PhotoEdit value, $Res Function(PhotoEdit) then) =
      _$PhotoEditCopyWithImpl<$Res, PhotoEdit>;
  @useResult
  $Res call(
      {bool clipMode,
      bool colorFilterMode,
      List<ColorFilterPreview> colorFilterPreviewImages,
      List<String> adaptivePresets,
      bool isInitialized,
      Uint8List? initialImage,
      Uint8List? editedImage,
      Offset cropOffset,
      Size cropSize,
      Size defaultSize,
      Size actualSize,
      int angle,
      List<EditedEmojiData> emojis,
      int? selectedEmojiIndex});
}

/// @nodoc
class _$PhotoEditCopyWithImpl<$Res, $Val extends PhotoEdit>
    implements $PhotoEditCopyWith<$Res> {
  _$PhotoEditCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PhotoEdit
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipMode = null,
    Object? colorFilterMode = null,
    Object? colorFilterPreviewImages = null,
    Object? adaptivePresets = null,
    Object? isInitialized = null,
    Object? initialImage = freezed,
    Object? editedImage = freezed,
    Object? cropOffset = null,
    Object? cropSize = null,
    Object? defaultSize = null,
    Object? actualSize = null,
    Object? angle = null,
    Object? emojis = null,
    Object? selectedEmojiIndex = freezed,
  }) {
    return _then(_value.copyWith(
      clipMode: null == clipMode
          ? _value.clipMode
          : clipMode // ignore: cast_nullable_to_non_nullable
              as bool,
      colorFilterMode: null == colorFilterMode
          ? _value.colorFilterMode
          : colorFilterMode // ignore: cast_nullable_to_non_nullable
              as bool,
      colorFilterPreviewImages: null == colorFilterPreviewImages
          ? _value.colorFilterPreviewImages
          : colorFilterPreviewImages // ignore: cast_nullable_to_non_nullable
              as List<ColorFilterPreview>,
      adaptivePresets: null == adaptivePresets
          ? _value.adaptivePresets
          : adaptivePresets // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isInitialized: null == isInitialized
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      initialImage: freezed == initialImage
          ? _value.initialImage
          : initialImage // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      editedImage: freezed == editedImage
          ? _value.editedImage
          : editedImage // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      cropOffset: null == cropOffset
          ? _value.cropOffset
          : cropOffset // ignore: cast_nullable_to_non_nullable
              as Offset,
      cropSize: null == cropSize
          ? _value.cropSize
          : cropSize // ignore: cast_nullable_to_non_nullable
              as Size,
      defaultSize: null == defaultSize
          ? _value.defaultSize
          : defaultSize // ignore: cast_nullable_to_non_nullable
              as Size,
      actualSize: null == actualSize
          ? _value.actualSize
          : actualSize // ignore: cast_nullable_to_non_nullable
              as Size,
      angle: null == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as int,
      emojis: null == emojis
          ? _value.emojis
          : emojis // ignore: cast_nullable_to_non_nullable
              as List<EditedEmojiData>,
      selectedEmojiIndex: freezed == selectedEmojiIndex
          ? _value.selectedEmojiIndex
          : selectedEmojiIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PhotoEditImplCopyWith<$Res>
    implements $PhotoEditCopyWith<$Res> {
  factory _$$PhotoEditImplCopyWith(
          _$PhotoEditImpl value, $Res Function(_$PhotoEditImpl) then) =
      __$$PhotoEditImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool clipMode,
      bool colorFilterMode,
      List<ColorFilterPreview> colorFilterPreviewImages,
      List<String> adaptivePresets,
      bool isInitialized,
      Uint8List? initialImage,
      Uint8List? editedImage,
      Offset cropOffset,
      Size cropSize,
      Size defaultSize,
      Size actualSize,
      int angle,
      List<EditedEmojiData> emojis,
      int? selectedEmojiIndex});
}

/// @nodoc
class __$$PhotoEditImplCopyWithImpl<$Res>
    extends _$PhotoEditCopyWithImpl<$Res, _$PhotoEditImpl>
    implements _$$PhotoEditImplCopyWith<$Res> {
  __$$PhotoEditImplCopyWithImpl(
      _$PhotoEditImpl _value, $Res Function(_$PhotoEditImpl) _then)
      : super(_value, _then);

  /// Create a copy of PhotoEdit
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? clipMode = null,
    Object? colorFilterMode = null,
    Object? colorFilterPreviewImages = null,
    Object? adaptivePresets = null,
    Object? isInitialized = null,
    Object? initialImage = freezed,
    Object? editedImage = freezed,
    Object? cropOffset = null,
    Object? cropSize = null,
    Object? defaultSize = null,
    Object? actualSize = null,
    Object? angle = null,
    Object? emojis = null,
    Object? selectedEmojiIndex = freezed,
  }) {
    return _then(_$PhotoEditImpl(
      clipMode: null == clipMode
          ? _value.clipMode
          : clipMode // ignore: cast_nullable_to_non_nullable
              as bool,
      colorFilterMode: null == colorFilterMode
          ? _value.colorFilterMode
          : colorFilterMode // ignore: cast_nullable_to_non_nullable
              as bool,
      colorFilterPreviewImages: null == colorFilterPreviewImages
          ? _value._colorFilterPreviewImages
          : colorFilterPreviewImages // ignore: cast_nullable_to_non_nullable
              as List<ColorFilterPreview>,
      adaptivePresets: null == adaptivePresets
          ? _value._adaptivePresets
          : adaptivePresets // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isInitialized: null == isInitialized
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      initialImage: freezed == initialImage
          ? _value.initialImage
          : initialImage // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      editedImage: freezed == editedImage
          ? _value.editedImage
          : editedImage // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
      cropOffset: null == cropOffset
          ? _value.cropOffset
          : cropOffset // ignore: cast_nullable_to_non_nullable
              as Offset,
      cropSize: null == cropSize
          ? _value.cropSize
          : cropSize // ignore: cast_nullable_to_non_nullable
              as Size,
      defaultSize: null == defaultSize
          ? _value.defaultSize
          : defaultSize // ignore: cast_nullable_to_non_nullable
              as Size,
      actualSize: null == actualSize
          ? _value.actualSize
          : actualSize // ignore: cast_nullable_to_non_nullable
              as Size,
      angle: null == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as int,
      emojis: null == emojis
          ? _value._emojis
          : emojis // ignore: cast_nullable_to_non_nullable
              as List<EditedEmojiData>,
      selectedEmojiIndex: freezed == selectedEmojiIndex
          ? _value.selectedEmojiIndex
          : selectedEmojiIndex // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$PhotoEditImpl implements _PhotoEdit {
  const _$PhotoEditImpl(
      {this.clipMode = false,
      this.colorFilterMode = false,
      final List<ColorFilterPreview> colorFilterPreviewImages = const [],
      final List<String> adaptivePresets = const [],
      this.isInitialized = false,
      this.initialImage,
      this.editedImage,
      this.cropOffset = const Offset(0, 0),
      this.cropSize = Size.zero,
      this.defaultSize = Size.zero,
      this.actualSize = Size.zero,
      this.angle = 0,
      final List<EditedEmojiData> emojis = const [],
      this.selectedEmojiIndex})
      : _colorFilterPreviewImages = colorFilterPreviewImages,
        _adaptivePresets = adaptivePresets,
        _emojis = emojis;

  @override
  @JsonKey()
  final bool clipMode;
  @override
  @JsonKey()
  final bool colorFilterMode;
  final List<ColorFilterPreview> _colorFilterPreviewImages;
  @override
  @JsonKey()
  List<ColorFilterPreview> get colorFilterPreviewImages {
    if (_colorFilterPreviewImages is EqualUnmodifiableListView)
      return _colorFilterPreviewImages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_colorFilterPreviewImages);
  }

  final List<String> _adaptivePresets;
  @override
  @JsonKey()
  List<String> get adaptivePresets {
    if (_adaptivePresets is EqualUnmodifiableListView) return _adaptivePresets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_adaptivePresets);
  }

  @override
  @JsonKey()
  final bool isInitialized;
  @override
  final Uint8List? initialImage;
  @override
  final Uint8List? editedImage;
  @override
  @JsonKey()
  final Offset cropOffset;
  @override
  @JsonKey()
  final Size cropSize;
  @override
  @JsonKey()
  final Size defaultSize;
  @override
  @JsonKey()
  final Size actualSize;
  @override
  @JsonKey()
  final int angle;
  final List<EditedEmojiData> _emojis;
  @override
  @JsonKey()
  List<EditedEmojiData> get emojis {
    if (_emojis is EqualUnmodifiableListView) return _emojis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_emojis);
  }

  @override
  final int? selectedEmojiIndex;

  @override
  String toString() {
    return 'PhotoEdit(clipMode: $clipMode, colorFilterMode: $colorFilterMode, colorFilterPreviewImages: $colorFilterPreviewImages, adaptivePresets: $adaptivePresets, isInitialized: $isInitialized, initialImage: $initialImage, editedImage: $editedImage, cropOffset: $cropOffset, cropSize: $cropSize, defaultSize: $defaultSize, actualSize: $actualSize, angle: $angle, emojis: $emojis, selectedEmojiIndex: $selectedEmojiIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PhotoEditImpl &&
            (identical(other.clipMode, clipMode) ||
                other.clipMode == clipMode) &&
            (identical(other.colorFilterMode, colorFilterMode) ||
                other.colorFilterMode == colorFilterMode) &&
            const DeepCollectionEquality().equals(
                other._colorFilterPreviewImages, _colorFilterPreviewImages) &&
            const DeepCollectionEquality()
                .equals(other._adaptivePresets, _adaptivePresets) &&
            (identical(other.isInitialized, isInitialized) ||
                other.isInitialized == isInitialized) &&
            const DeepCollectionEquality()
                .equals(other.initialImage, initialImage) &&
            const DeepCollectionEquality()
                .equals(other.editedImage, editedImage) &&
            (identical(other.cropOffset, cropOffset) ||
                other.cropOffset == cropOffset) &&
            (identical(other.cropSize, cropSize) ||
                other.cropSize == cropSize) &&
            (identical(other.defaultSize, defaultSize) ||
                other.defaultSize == defaultSize) &&
            (identical(other.actualSize, actualSize) ||
                other.actualSize == actualSize) &&
            (identical(other.angle, angle) || other.angle == angle) &&
            const DeepCollectionEquality().equals(other._emojis, _emojis) &&
            (identical(other.selectedEmojiIndex, selectedEmojiIndex) ||
                other.selectedEmojiIndex == selectedEmojiIndex));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      clipMode,
      colorFilterMode,
      const DeepCollectionEquality().hash(_colorFilterPreviewImages),
      const DeepCollectionEquality().hash(_adaptivePresets),
      isInitialized,
      const DeepCollectionEquality().hash(initialImage),
      const DeepCollectionEquality().hash(editedImage),
      cropOffset,
      cropSize,
      defaultSize,
      actualSize,
      angle,
      const DeepCollectionEquality().hash(_emojis),
      selectedEmojiIndex);

  /// Create a copy of PhotoEdit
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PhotoEditImplCopyWith<_$PhotoEditImpl> get copyWith =>
      __$$PhotoEditImplCopyWithImpl<_$PhotoEditImpl>(this, _$identity);
}

abstract class _PhotoEdit implements PhotoEdit {
  const factory _PhotoEdit(
      {final bool clipMode,
      final bool colorFilterMode,
      final List<ColorFilterPreview> colorFilterPreviewImages,
      final List<String> adaptivePresets,
      final bool isInitialized,
      final Uint8List? initialImage,
      final Uint8List? editedImage,
      final Offset cropOffset,
      final Size cropSize,
      final Size defaultSize,
      final Size actualSize,
      final int angle,
      final List<EditedEmojiData> emojis,
      final int? selectedEmojiIndex}) = _$PhotoEditImpl;

  @override
  bool get clipMode;
  @override
  bool get colorFilterMode;
  @override
  List<ColorFilterPreview> get colorFilterPreviewImages;
  @override
  List<String> get adaptivePresets;
  @override
  bool get isInitialized;
  @override
  Uint8List? get initialImage;
  @override
  Uint8List? get editedImage;
  @override
  Offset get cropOffset;
  @override
  Size get cropSize;
  @override
  Size get defaultSize;
  @override
  Size get actualSize;
  @override
  int get angle;
  @override
  List<EditedEmojiData> get emojis;
  @override
  int? get selectedEmojiIndex;

  /// Create a copy of PhotoEdit
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PhotoEditImplCopyWith<_$PhotoEditImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ColorFilterPreview {
  String get name => throw _privateConstructorUsedError;
  Uint8List? get image => throw _privateConstructorUsedError;

  /// Create a copy of ColorFilterPreview
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ColorFilterPreviewCopyWith<ColorFilterPreview> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ColorFilterPreviewCopyWith<$Res> {
  factory $ColorFilterPreviewCopyWith(
          ColorFilterPreview value, $Res Function(ColorFilterPreview) then) =
      _$ColorFilterPreviewCopyWithImpl<$Res, ColorFilterPreview>;
  @useResult
  $Res call({String name, Uint8List? image});
}

/// @nodoc
class _$ColorFilterPreviewCopyWithImpl<$Res, $Val extends ColorFilterPreview>
    implements $ColorFilterPreviewCopyWith<$Res> {
  _$ColorFilterPreviewCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ColorFilterPreview
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? image = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ColorFilterPreviewImplCopyWith<$Res>
    implements $ColorFilterPreviewCopyWith<$Res> {
  factory _$$ColorFilterPreviewImplCopyWith(_$ColorFilterPreviewImpl value,
          $Res Function(_$ColorFilterPreviewImpl) then) =
      __$$ColorFilterPreviewImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, Uint8List? image});
}

/// @nodoc
class __$$ColorFilterPreviewImplCopyWithImpl<$Res>
    extends _$ColorFilterPreviewCopyWithImpl<$Res, _$ColorFilterPreviewImpl>
    implements _$$ColorFilterPreviewImplCopyWith<$Res> {
  __$$ColorFilterPreviewImplCopyWithImpl(_$ColorFilterPreviewImpl _value,
      $Res Function(_$ColorFilterPreviewImpl) _then)
      : super(_value, _then);

  /// Create a copy of ColorFilterPreview
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? image = freezed,
  }) {
    return _then(_$ColorFilterPreviewImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$ColorFilterPreviewImpl implements _ColorFilterPreview {
  const _$ColorFilterPreviewImpl({required this.name, this.image});

  @override
  final String name;
  @override
  final Uint8List? image;

  @override
  String toString() {
    return 'ColorFilterPreview(name: $name, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ColorFilterPreviewImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.image, image));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(image));

  /// Create a copy of ColorFilterPreview
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ColorFilterPreviewImplCopyWith<_$ColorFilterPreviewImpl> get copyWith =>
      __$$ColorFilterPreviewImplCopyWithImpl<_$ColorFilterPreviewImpl>(
          this, _$identity);
}

abstract class _ColorFilterPreview implements ColorFilterPreview {
  const factory _ColorFilterPreview(
      {required final String name,
      final Uint8List? image}) = _$ColorFilterPreviewImpl;

  @override
  String get name;
  @override
  Uint8List? get image;

  /// Create a copy of ColorFilterPreview
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ColorFilterPreviewImplCopyWith<_$ColorFilterPreviewImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EditedEmojiData {
  MisskeyEmojiData get emoji => throw _privateConstructorUsedError;
  double get scale => throw _privateConstructorUsedError;
  Offset get position => throw _privateConstructorUsedError;
  double get angle => throw _privateConstructorUsedError;

  /// Create a copy of EditedEmojiData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EditedEmojiDataCopyWith<EditedEmojiData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditedEmojiDataCopyWith<$Res> {
  factory $EditedEmojiDataCopyWith(
          EditedEmojiData value, $Res Function(EditedEmojiData) then) =
      _$EditedEmojiDataCopyWithImpl<$Res, EditedEmojiData>;
  @useResult
  $Res call(
      {MisskeyEmojiData emoji, double scale, Offset position, double angle});
}

/// @nodoc
class _$EditedEmojiDataCopyWithImpl<$Res, $Val extends EditedEmojiData>
    implements $EditedEmojiDataCopyWith<$Res> {
  _$EditedEmojiDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EditedEmojiData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? emoji = null,
    Object? scale = null,
    Object? position = null,
    Object? angle = null,
  }) {
    return _then(_value.copyWith(
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as MisskeyEmojiData,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as Offset,
      angle: null == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EditedEmojiDataImplCopyWith<$Res>
    implements $EditedEmojiDataCopyWith<$Res> {
  factory _$$EditedEmojiDataImplCopyWith(_$EditedEmojiDataImpl value,
          $Res Function(_$EditedEmojiDataImpl) then) =
      __$$EditedEmojiDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {MisskeyEmojiData emoji, double scale, Offset position, double angle});
}

/// @nodoc
class __$$EditedEmojiDataImplCopyWithImpl<$Res>
    extends _$EditedEmojiDataCopyWithImpl<$Res, _$EditedEmojiDataImpl>
    implements _$$EditedEmojiDataImplCopyWith<$Res> {
  __$$EditedEmojiDataImplCopyWithImpl(
      _$EditedEmojiDataImpl _value, $Res Function(_$EditedEmojiDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of EditedEmojiData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? emoji = null,
    Object? scale = null,
    Object? position = null,
    Object? angle = null,
  }) {
    return _then(_$EditedEmojiDataImpl(
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as MisskeyEmojiData,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as Offset,
      angle: null == angle
          ? _value.angle
          : angle // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$EditedEmojiDataImpl implements _EditedEmojiData {
  const _$EditedEmojiDataImpl(
      {required this.emoji,
      required this.scale,
      required this.position,
      required this.angle});

  @override
  final MisskeyEmojiData emoji;
  @override
  final double scale;
  @override
  final Offset position;
  @override
  final double angle;

  @override
  String toString() {
    return 'EditedEmojiData(emoji: $emoji, scale: $scale, position: $position, angle: $angle)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditedEmojiDataImpl &&
            (identical(other.emoji, emoji) || other.emoji == emoji) &&
            (identical(other.scale, scale) || other.scale == scale) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.angle, angle) || other.angle == angle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, emoji, scale, position, angle);

  /// Create a copy of EditedEmojiData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EditedEmojiDataImplCopyWith<_$EditedEmojiDataImpl> get copyWith =>
      __$$EditedEmojiDataImplCopyWithImpl<_$EditedEmojiDataImpl>(
          this, _$identity);
}

abstract class _EditedEmojiData implements EditedEmojiData {
  const factory _EditedEmojiData(
      {required final MisskeyEmojiData emoji,
      required final double scale,
      required final Offset position,
      required final double angle}) = _$EditedEmojiDataImpl;

  @override
  MisskeyEmojiData get emoji;
  @override
  double get scale;
  @override
  Offset get position;
  @override
  double get angle;

  /// Create a copy of EditedEmojiData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EditedEmojiDataImplCopyWith<_$EditedEmojiDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
